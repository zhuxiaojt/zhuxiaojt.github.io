<html>
  <head>
    <title>Zhuxiao Open Markdown Render</title>
    <script src="./marked.min.js"></script>
    <link rel="stylesheet" href="./katex.min.css" crossorigin="anonymous">
    <script src="./katex.min.js" crossorigin="anonymous"></script>
    <script src="./highlight.min.js"></script>
    <link rel="stylesheet" href="./hljsStyle.css">
    <style>
      html,body{
        background-color: transparent;
      }
      .markdown-render blockquote {
        border-left: 4px solid #bbbbbb;
        padding: 8px 16px;
        margin: 12px 0;
      }
      .markdown-render table {
        border-collapse: collapse;
        width: 100%;
        margin: 16px 0;
      }
      .markdown-render th, .markdown-render td {
        border: 1px solid #e0e0e0;
        padding: 8px 12px;
      }
      .markdown-render th {
        background: #f5f5f5;
      }
    </style>
  </head>
  <body>
    <div class="markdown-render" id="markdownRender">
      <p>Waiting...</p>
    </div>
    <script>
      let markdownRender = document.getElementById('markdownRender');
      function renderMarkdownWithKaTeX(markdownContent) {
          markdownRender.textContent="<p>Loading...</p>";
          // LaTeX公式占位符替换
          let mathBlocks = [];
          let processedContent = markdownContent.replace(/\$\$(.*?)\$\$/gs, (match, content) => {
            const index = mathBlocks.length;
            mathBlocks.push(content);
            return `[[KATEX_BLOCK_${index}]]`;
          });
        
          let mathInlines = [];
          processedContent = processedContent.replace(/(?<!\$)\$(?!\$)(.*?)(?<!\$)\$(?!\$)/g, (match, content) => {
            const index = mathInlines.length;
            mathInlines.push(content);
            return `[[KATEX_INLINE_${index}]]`;
          });
        
          // Markdown解析
          marked.setOptions({
            highlight: (code, lang) => lang && hljs.getLanguage(lang) ? hljs.highlight(code, { language: lang }).value : hljs.highlightAuto(code).value,
            gfm: true,
            breaks: true
          });
          let htmlContent = marked.parse(processedContent);
        
          // 渲染LaTeX块级公式
          htmlContent = htmlContent.replace(/\[\[KATEX_BLOCK_(\d+)\]\]/g, (match, index) => {
            try {
              return katex.renderToString(mathBlocks[parseInt(index)], { displayMode: true, throwOnError: false });
            } catch (err) {
              return `<div class="katex-error">公式渲染失败：${mathBlocks[parseInt(index)]}</div>`;
            }
          });
        
          // 渲染LaTeX行内公式
          htmlContent = htmlContent.replace(/\[\[KATEX_INLINE_(\d+)\]\]/g, (match, index) => {
            try {
              return katex.renderToString(mathInlines[parseInt(index)], { displayMode: false, throwOnError: false });
            } catch (err) {
              return `<span class="katex-error">公式渲染失败：${mathInlines[parseInt(index)]}</span>`;
            }
          });
        
          // 插入渲染内容 + 代码高亮
          markdownRender.innerHTML = htmlContent;
          document.querySelectorAll('.markdown-render pre code').forEach(block => hljs.highlightElement(block));
      }
      window.addEventListener('message', function (e) {
        let msg = e.data;
        if (!msg || !msg.type) return;
  
        // ========== 指令1：injectStyle 样式注入 ==========
        let injectStyleId = 'parent-inject-style';
        if (msg.type === 'injectStyle' && typeof msg.css === 'string' && msg.css.trim()) {
          let oldStyle = document.getElementById(injectStyleId);
          if (oldStyle) oldStyle.remove();
          // 步骤2：创建新的style标签
          let newStyle = document.createElement('style');
          newStyle.id = injectStyleId;
          newStyle.textContent = msg.css;
          // 步骤3：插入到head中生效
          document.head.appendChild(newStyle);
        }
  
        // ========== 指令2：SetRenderText 执行渲染 ==========
        if (msg.type === 'SetRenderText' && typeof msg.text === 'string' && msg.text.trim()) {
          renderMarkdownWithKaTeX(msg.text);
        }

        // ========== 指令3：GetHTML 获取HTML ==========
        if (msg.type === 'GetHTML' && typeof msg.listenEventType === 'string' && msg.listenEventType.trim()) {
          window.parent.postMessage({type:msg.listenEventType,html:markdownRender.textContent},'*');
        }
      });
    </script>
  </body>
</html>
