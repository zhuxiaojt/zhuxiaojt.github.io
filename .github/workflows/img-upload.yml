name: 图床上传API

on:
  workflow_dispatch:
    inputs:
      operation:
        description: '操作类型'
        required: true
        type: choice
        options:
          - single    # 单文件上传
          - start     # 开始分块上传
          - chunk     # 上传分块
          - complete  # 完成上传
          - cleanup   # 清理过期文件
      fileId:
        description: '文件ID'
        required: false
        default: ''
        type: string
      chunkIndex:
        description: '分块序号'
        required: false
        default: ''
        type: string
      totalChunks:
        description: '总分块数'
        required: false
        default: ''
        type: string
      fileExtension:
        description: '文件扩展名'
        required: false
        default: ''
        type: string
      chunkData:
        description: '分块数据Base64'
        required: false
        default: ''
        type: string
      fileName:
        description: '文件名'
        required: false
        default: ''
        type: string
      base64Content:
        description: '完整文件Base64'
        required: false
        default: ''
        type: string

jobs:
  file-upload:
    runs-on: ubuntu-latest
    timeout-minutes: 60  # 整个job最多运行1小时
    permissions:
      contents: write
    env:
      UPLOAD_DIR: "img"
      TEMP_DIR: "temp_uploads"
      COUNTER_FILE: "api/img/cnt.txt"
      REPO: ${{ github.repository }}
      GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      
    steps:
      - name: 初始化环境
        id: init
        run: |
          echo "OPERATION=${{ github.event.inputs.operation }}" >> $GITHUB_ENV
          echo "FILE_ID=${{ github.event.inputs.fileId }}" >> $GITHUB_ENV
          echo "CHUNK_INDEX=${{ github.event.inputs.chunkIndex }}" >> $GITHUB_ENV
          echo "TOTAL_CHUNKS=${{ github.event.inputs.totalChunks }}" >> $GITHUB_ENV
          echo "FILE_EXT=${{ github.event.inputs.fileExtension }}" >> $GITHUB_ENV
          echo "CHUNK_DATA=${{ github.event.inputs.chunkData }}" >> $GITHUB_ENV
          echo "FILE_NAME=${{ github.event.inputs.fileName }}" >> $GITHUB_ENV
          echo "BASE64_CONTENT=${{ github.event.inputs.base64Content }}" >> $GITHUB_ENV
          echo "START_TIME=$(date +%s)" >> $GITHUB_ENV
          
      # ==================== 单文件上传模式 ====================
      - name: 处理单文件上传
        if: env.OPERATION == 'single' && env.BASE64_CONTENT != ''
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          echo "=== 单文件上传模式 ==="
          
          # 读取计数器文件
          COUNTER_RESPONSE=$(curl -s -H "Authorization: token $GITHUB_TOKEN" \
            "https://api.github.com/repos/${{ env.REPO }}/contents/${{ env.COUNTER_FILE }}")
          
          FILE_CONTENT=$(echo "$COUNTER_RESPONSE" | jq -r '.content // empty')
          if [ -z "$FILE_CONTENT" ]; then
            echo "❌ 错误：计数器文件不存在或为空"
            exit 1
          fi
          
          FILE_NUM=$(echo "$FILE_CONTENT" | base64 -d)
          if ! [[ $FILE_NUM =~ ^[0-9]+$ ]]; then
            echo "❌ 错误：计数器文件内容不是有效数字: '$FILE_NUM'"
            exit 1
          fi
          
          NEW_NUM=$((FILE_NUM + 1))
          
          # 生成文件名
          ORIGIN_NAME="${{ env.FILE_NAME }}"
          if [[ "$ORIGIN_NAME" == *.* ]]; then
            FILE_EXT=".${ORIGIN_NAME##*.}"
          else
            FILE_EXT=""
          fi
          
          FINAL_FILENAME="$NEW_NUM$FILE_EXT"
          UPLOAD_PATH="${{ env.UPLOAD_DIR }}/$FINAL_FILENAME"
          
          echo "正在上传文件: $FINAL_FILENAME"
          
          # 上传文件
          curl -X PUT -s \
            -H "Authorization: token $GITHUB_TOKEN" \
            -H "Accept: application/vnd.github+json" \
            -d "{\"message\":\"上传文件: $FINAL_FILENAME\",\"content\":\"${{ env.BASE64_CONTENT }}\",\"branch\":\"main\"}" \
            "https://api.github.com/repos/${{ env.REPO }}/contents/$UPLOAD_PATH"
          
          # 更新计数器
          COUNTER_SHA=$(echo "$COUNTER_RESPONSE" | jq -r '.sha')
          NEW_NUM_BASE64=$(echo -n "$NEW_NUM" | base64)
          
          curl -X PUT -s \
            -H "Authorization: token $GITHUB_TOKEN" \
            -H "Accept: application/vnd.github+json" \
            -d "{\"message\":\"更新计数器: $NEW_NUM\",\"content\":\"$NEW_NUM_BASE64\",\"sha\":\"$COUNTER_SHA\",\"branch\":\"main\"}" \
            "https://api.github.com/repos/${{ env.REPO }}/contents/${{ env.COUNTER_FILE }}"
          
          echo "✅ 上传成功！"
          echo "📁 文件名: $FINAL_FILENAME"
          echo "📍 路径: $UPLOAD_PATH"
          echo "🔗 Raw URL: https://raw.githubusercontent.com/${{ env.REPO }}/main/$UPLOAD_PATH"
          echo "🌐 CDN URL: https://cdn.jsdelivr.net/gh/${{ env.REPO }}/$UPLOAD_PATH"
          
      # ==================== 开始分块上传 ====================
      - name: 开始分块上传
        if: env.OPERATION == 'start'
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          echo "=== 开始分块上传 ==="
          
          # 验证输入
          if [ -z "${{ env.TOTAL_CHUNKS }}" ] || [ -z "${{ env.FILE_EXT }}" ]; then
            echo "❌ 错误：缺少必要参数 (totalChunks, fileExtension)"
            exit 1
          fi
          
          # 读取计数器文件
          COUNTER_RESPONSE=$(curl -s -H "Authorization: token $GITHUB_TOKEN" \
            "https://api.github.com/repos/${{ env.REPO }}/contents/${{ env.COUNTER_FILE }}")
          
          FILE_CONTENT=$(echo "$COUNTER_RESPONSE" | jq -r '.content // empty')
          if [ -z "$FILE_CONTENT" ]; then
            echo "❌ 错误：计数器文件不存在或为空"
            exit 1
          fi
          
          FILE_NUM=$(echo "$FILE_CONTENT" | base64 -d)
          if ! [[ $FILE_NUM =~ ^[0-9]+$ ]]; then
            echo "❌ 错误：计数器文件内容不是有效数字: '$FILE_NUM'"
            exit 1
          fi
          
          NEW_NUM=$((FILE_NUM + 1))
          
          # 创建状态文件
          TOTAL_CHUNKS=${{ env.TOTAL_CHUNKS }}
          FILE_EXT="${{ env.FILE_EXT }}"
          
          # 初始化所有分块状态为 pending
          CHUNKS_JSON="{"
          for i in $(seq 0 $((TOTAL_CHUNKS - 1))); do
            if [ $i -gt 0 ]; then
              CHUNKS_JSON="$CHUNKS_JSON,"
            fi
            CHUNKS_JSON="$CHUNKS_JSON\"$i\":\"pending\""
          done
          CHUNKS_JSON="$CHUNKS_JSON}"
          
          STATUS_JSON=$(jq -n \
            --arg fileId "$NEW_NUM" \
            --arg extension "$FILE_EXT" \
            --arg totalChunks "$TOTAL_CHUNKS" \
            --arg startTime "$(date +%s)" \
            --argjson chunks "$CHUNKS_JSON" \
            '{
              fileId: $fileId,
              extension: $extension,
              totalChunks: $totalChunks | tonumber,
              startTime: $startTime | tonumber,
              chunks: $chunks
            }')
          
          STATUS_BASE64=$(echo -n "$STATUS_JSON" | base64 -w 0)
          
          # 创建状态文件
          STATUS_FILE="${{ env.TEMP_DIR }}/TEMPMETA_${NEW_NUM}.json"
          echo "创建状态文件: $STATUS_FILE"
          
          curl -X PUT -s \
            -H "Authorization: token $GITHUB_TOKEN" \
            -H "Accept: application/vnd.github+json" \
            -d "{\"message\":\"开始分块上传: $NEW_NUM\",\"content\":\"$STATUS_BASE64\",\"branch\":\"main\"}" \
            "https://api.github.com/repos/${{ env.REPO }}/contents/$STATUS_FILE"
          
          # 立即更新计数器（避免冲突）
          COUNTER_SHA=$(echo "$COUNTER_RESPONSE" | jq -r '.sha')
          NEW_NUM_BASE64=$(echo -n "$NEW_NUM" | base64 -w 0)
          
          curl -X PUT -s \
            -H "Authorization: token $GITHUB_TOKEN" \
            -H "Accept: application/vnd.github+json" \
            -d "{\"message\":\"预分配文件编号: $NEW_NUM\",\"content\":\"$NEW_NUM_BASE64\",\"sha\":\"$COUNTER_SHA\",\"branch\":\"main\"}" \
            "https://api.github.com/repos/${{ env.REPO }}/contents/${{ env.COUNTER_FILE }}"
          
          echo "✅ 开始上传成功！"
          echo "📄 文件ID: $NEW_NUM"
          echo "📎 扩展名: $FILE_EXT"
          echo "🔢 总分块数: $TOTAL_CHUNKS"
          echo "📋 状态文件: $STATUS_FILE"
          
      # ==================== 上传分块 ====================
      # ==================== 完成上传（完全修复版）====================
      - name: 完成分块上传
        if: env.OPERATION == 'complete'
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          echo "=== 完成分块上传 ==="
          
          if [ -z "${{ env.FILE_ID }}" ]; then
            echo "❌ 错误：缺少必要参数 (fileId)"
            exit 1
          fi
          
          FILE_ID="${{ env.FILE_ID }}"
          START_TIME=$(date +%s)
          MAX_WAIT=1800  # 30分钟，等待所有分块完成
          
          # 1. 首先检查状态文件是否存在
          STATUS_FILE="${{ env.TEMP_DIR }}/TEMPMETA_${FILE_ID}.json"
          
          # 等待状态文件出现（可能还在创建中）
          echo "等待状态文件出现..."
          for i in $(seq 1 30); do  # 最多等30秒
            STATUS_RESPONSE=$(curl -s -H "Authorization: token $GITHUB_TOKEN" \
              "https://api.github.com/repos/${{ env.REPO }}/contents/$STATUS_FILE")
            
            if ! echo "$STATUS_RESPONSE" | grep -q '"message":"Not Found"'; then
              echo "状态文件已找到"
              break
            fi
            
            if [ $i -eq 30 ]; then
              echo "❌ 错误：状态文件不存在，上传可能已取消"
              exit 1
            fi
            
            echo "等待状态文件... ($i/30)"
            sleep 1
          done
          
          # 2. 等待所有分块完成
          echo "等待所有分块上传完成..."
          ALL_COMPLETED=false
          TOTAL_CHUNKS=0
          FILE_EXT=""
          
          while true; do
            CURRENT_TIME=$(date +%s)
            ELAPSED=$((CURRENT_TIME - START_TIME))
            
            # 超时检查
            if [ $ELAPSED -gt $MAX_WAIT ]; then
              echo "❌ 等待超时（30分钟），可能还有分块未完成"
              exit 1
            fi
            
            # 读取状态文件
            STATUS_RESPONSE=$(curl -s -H "Authorization: token $GITHUB_TOKEN" \
              "https://api.github.com/repos/${{ env.REPO }}/contents/$STATUS_FILE")
            
            if echo "$STATUS_RESPONSE" | grep -q '"message":"Not Found"'; then
              echo "❌ 错误：状态文件在等待过程中被删除"
              exit 1
            fi
            
            STATUS_CONTENT=$(echo "$STATUS_RESPONSE" | jq -r '.content // empty' | base64 -d)
            if [ -z "$STATUS_CONTENT" ]; then
              echo "⏳ 状态文件内容为空，等待5秒..."
              sleep 5
              continue
            fi
            
            # 获取总分块数和扩展名
            TOTAL_CHUNKS=$(echo "$STATUS_CONTENT" | jq -r '.totalChunks')
            FILE_EXT=$(echo "$STATUS_CONTENT" | jq -r '.extension')
            
            # 检查所有分块状态
            ALL_COMPLETED=true
            INCOMPLETE_CHUNKS=0
            
            for i in $(seq 0 $((TOTAL_CHUNKS - 1))); do
              STATUS=$(echo "$STATUS_CONTENT" | jq -r ".chunks[\"$i\"] // \"pending\"")
              if [ "$STATUS" != "completed" ]; then
                ALL_COMPLETED=false
                INCOMPLETE_CHUNKS=$((INCOMPLETE_CHUNKS + 1))
              fi
            done
            
            if [ "$ALL_COMPLETED" = "true" ]; then
              echo "✅ 所有分块已完成，可以开始合并"
              break
            else
              echo "⏳ 还有 $INCOMPLETE_CHUNKS/$TOTAL_CHUNKS 个分块未完成，已等待 ${ELAPSED}秒..."
              sleep 10  # 等待10秒后再次检查
            fi
          done
          
          echo "✅ 所有分块已完成，开始合并..."
          
          # 3. 创建临时文件合并所有分块
          TEMP_FILE="/tmp/merged_${FILE_ID}"
          rm -f "$TEMP_FILE"
          
          for i in $(seq 0 $((TOTAL_CHUNKS - 1))); do
            CHUNK_FILE="${{ env.TEMP_DIR }}/TEMPCHUNK_${FILE_ID}_${i}.dat"
            echo "下载分块 $i..."
            
            CHUNK_RESPONSE=$(curl -s -H "Authorization: token $GITHUB_TOKEN" \
              "https://api.github.com/repos/${{ env.REPO }}/contents/$CHUNK_FILE")
            
            CHUNK_CONTENT=$(echo "$CHUNK_RESPONSE" | jq -r '.content // empty')
            if [ -z "$CHUNK_CONTENT" ]; then
              echo "❌ 错误：分块 $i 数据缺失"
              exit 1
            fi
            
            echo "$CHUNK_CONTENT" | base64 -d >> "$TEMP_FILE"
            echo "分块 $i 合并完成"
          done
          
          # 4. 使用Python处理大文件上传（避免shell参数限制）
          FINAL_FILENAME="${FILE_ID}${FILE_EXT}"
          FINAL_PATH="${{ env.UPLOAD_DIR }}/${FINAL_FILENAME}"
          
          echo "正在编码文件为Base64并上传..."
          echo "文件大小: $(stat -c%s "$TEMP_FILE") 字节"
          
          # 使用Python处理大文件上传
          python3 << 'EOF'
import os
import sys
import json
import base64
import subprocess

file_id = os.environ.get('FILE_ID')
repo = os.environ.get('REPO')
github_token = os.environ.get('GITHUB_TOKEN')
temp_file = f"/tmp/merged_{file_id}"
final_filename = f"{file_id}.png"  # 假设是png，实际情况根据文件扩展名确定
final_path = f"img/{final_filename}"

# 读取文件并编码为Base64
print(f"正在读取文件: {temp_file}")
with open(temp_file, 'rb') as f:
    file_data = f.read()

print(f"文件大小: {len(file_data)} 字节")

# 分块读取和上传（避免内存不足）
def upload_in_chunks(file_path, chunk_size_mb=1):
    """分块上传文件到GitHub"""
    chunk_size = chunk_size_mb * 1024 * 1024  # MB转字节
    all_base64_parts = []
    
    with open(file_path, 'rb') as f:
        chunk_count = 0
        while True:
            chunk = f.read(chunk_size)
            if not chunk:
                break
            chunk_count += 1
            print(f"编码分块 {chunk_count}...")
            # 编码当前分块
            chunk_base64 = base64.b64encode(chunk).decode('utf-8')
            all_base64_parts.append(chunk_base64)
    
    # 如果文件很小，直接上传
    if chunk_count == 1:
        full_base64 = all_base64_parts[0]
        payload = {
            "message": f"上传文件: {final_filename}",
            "content": full_base64,
            "branch": "main"
        }
        
        # 写入临时JSON文件
        json_file = f"/tmp/upload_{file_id}.json"
        with open(json_file, 'w') as f:
            json.dump(payload, f)
        
        # 使用curl上传
        cmd = [
            'curl', '-X', 'PUT',
            '-H', f'Authorization: token {github_token}',
            '-H', 'Accept: application/vnd.github+json',
            '-H', 'Content-Type: application/json',
            '--data-binary', f'@{json_file}',
            f'https://api.github.com/repos/{repo}/contents/{final_path}'
        ]
        
        result = subprocess.run(cmd, capture_output=True, text=True)
        print(f"上传结果: {result.returncode}")
        if result.returncode != 0:
            print(f"错误: {result.stderr}")
        
        # 清理临时文件
        os.remove(json_file)
    else:
        print(f"⚠️ 文件过大 ({chunk_count} 个分块)，需要特殊处理")
        # 这里可以添加大文件的特殊处理逻辑
        return False
    
    return True

# 尝试上传
if upload_in_chunks(temp_file):
    print("✅ 上传成功！")
    print(f"📁 文件名: {final_filename}")
    print(f"📍 路径: {final_path}")
    print(f"🔗 Raw URL: https://raw.githubusercontent.com/{repo}/main/{final_path}")
else:
    print("❌ 上传失败")
    sys.exit(1)
EOF
          
          # 5. 清理临时文件
          echo "清理临时文件..."
          
          # 清理分块数据文件
          for i in $(seq 0 $((TOTAL_CHUNKS - 1))); do
            CHUNK_FILE="${{ env.TEMP_DIR }}/TEMPCHUNK_${FILE_ID}_${i}.dat"
            CHUNK_RESPONSE=$(curl -s -H "Authorization: token $GITHUB_TOKEN" \
              "https://api.github.com/repos/${{ env.REPO }}/contents/$CHUNK_FILE")
            
            if ! echo "$CHUNK_RESPONSE" | grep -q '"message":"Not Found"'; then
              CHUNK_SHA=$(echo "$CHUNK_RESPONSE" | jq -r '.sha // empty')
              if [ -n "$CHUNK_SHA" ] && [ "$CHUNK_SHA" != "null" ]; then
                curl -X DELETE -s \
                  -H "Authorization: token $GITHUB_TOKEN" \
                  -H "Accept: application/vnd.github+json" \
                  -d "{\"message\":\"清理分块 $i\",\"sha\":\"$CHUNK_SHA\",\"branch\":\"main\"}" \
                  "https://api.github.com/repos/${{ env.REPO }}/contents/$CHUNK_FILE"
                echo "清理分块 $i 文件"
              fi
            fi
          done
          
          # 清理状态文件
          STATUS_SHA=$(echo "$STATUS_RESPONSE" | jq -r '.sha // empty')
          if [ -n "$STATUS_SHA" ] && [ "$STATUS_SHA" != "null" ]; then
            curl -X DELETE -s \
              -H "Authorization: token $GITHUB_TOKEN" \
              -H "Accept: application/vnd.github+json" \
              -d "{\"message\":\"清理状态文件\",\"sha\":\"$STATUS_SHA\",\"branch\":\"main\"}" \
              "https://api.github.com/repos/${{ env.REPO }}/contents/$STATUS_FILE"
            echo "清理状态文件"
          fi
          
          echo "✅ 文件上传完成！"
          
      # ==================== 清理过期文件 ====================
      - name: 清理过期临时文件
        if: env.OPERATION == 'cleanup'
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          echo "=== 清理过期临时文件 ==="
          
          CURRENT_TIME=$(date +%s)
          MAX_AGE=3600  # 1小时
          
          # 获取 temp_uploads 目录内容
          TEMP_DIR_CONTENT=$(curl -s -H "Authorization: token $GITHUB_TOKEN" \
            "https://api.github.com/repos/${{ env.REPO }}/contents/${{ env.TEMP_DIR }}")
          
          # 清理状态文件
          echo "检查状态文件..."
          echo "$TEMP_DIR_CONTENT" | jq -r '.[] | select(.name | startswith("TEMPMETA_")) | .name' | while read -r FILE; do
            echo "检查文件: $FILE"
            
            FILE_RESPONSE=$(curl -s -H "Authorization: token $GITHUB_TOKEN" \
              "https://api.github.com/repos/${{ env.REPO }}/contents/${{ env.TEMP_DIR }}/$FILE")
            
            FILE_CONTENT=$(echo "$FILE_RESPONSE" | jq -r '.content // empty' | base64 -d)
            if [ -n "$FILE_CONTENT" ]; then
              START_TIME=$(echo "$FILE_CONTENT" | jq -r '.startTime // 0')
              AGE=$((CURRENT_TIME - START_TIME))
              
              if [ $AGE -gt $MAX_AGE ]; then
                echo "清理过期状态文件: $FILE (创建于 ${AGE}秒前)"
                FILE_SHA=$(echo "$FILE_RESPONSE" | jq -r '.sha // empty')
                
                if [ -n "$FILE_SHA" ] && [ "$FILE_SHA" != "null" ]; then
                  curl -X DELETE -s \
                    -H "Authorization: token $GITHUB_TOKEN" \
                    -H "Accept: application/vnd.github+json" \
                    -d "{\"message\":\"清理过期状态文件\",\"sha\":\"$FILE_SHA\",\"branch\":\"main\"}" \
                    "https://api.github.com/repos/${{ env.REPO }}/contents/${{ env.TEMP_DIR }}/$FILE"
                  
                  # 提取文件ID
                  FILE_ID=$(echo "$FILE" | sed 's/TEMPMETA_//' | sed 's/.json//')
                  
                  # 清理对应的分块文件
                  echo "清理文件ID $FILE_ID 的分块文件..."
                  for i in $(seq 0 99); do  # 假设最多100个分块
                    CHUNK_FILE="${{ env.TEMP_DIR }}/TEMPCHUNK_${FILE_ID}_${i}.dat"
                    CHUNK_RESPONSE=$(curl -s -H "Authorization: token $GITHUB_TOKEN" \
                      "https://api.github.com/repos/${{ env.REPO }}/contents/$CHUNK_FILE")
                    
                    if ! echo "$CHUNK_RESPONSE" | grep -q '"message":"Not Found"'; then
                      CHUNK_SHA=$(echo "$CHUNK_RESPONSE" | jq -r '.sha // empty')
                      if [ -n "$CHUNK_SHA" ] && [ "$CHUNK_SHA" != "null" ]; then
                        curl -X DELETE -s \
                          -H "Authorization: token $GITHUB_TOKEN" \
                          -H "Accept: application/vnd.github+json" \
                          -d "{\"message\":\"清理过期分块\",\"sha\":\"$CHUNK_SHA\",\"branch\":\"main\"}" \
                          "https://api.github.com/repos/${{ env.REPO }}/contents/$CHUNK_FILE"
                      fi
                    fi
                  done
                fi
              else
                echo "保留状态文件: $FILE (创建于 ${AGE}秒前)"
              fi
            fi
          done
          
          echo "✅ 过期文件清理完成"
